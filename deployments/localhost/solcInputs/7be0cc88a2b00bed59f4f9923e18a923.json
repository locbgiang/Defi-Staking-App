{
  "language": "Solidity",
  "sources": {
    "contracts/Staking.sol": {
      "content": "// stake: Lock tokens into our smart contract (check)\r\n// withdraw: unlock tokens and pull out of the contract (check)\r\n// claimReward: users get their reward tokens\r\n//      what's a good reward mechanism?\r\n//      what's some good reward math?\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.7;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\nerror Staking__TransferFailed();\r\nerror Staking__NeedsMoreThanZero();\r\n\r\ncontract Staking {\r\n    IERC20 public s_stakingToken;\r\n    IERC20 public s_rewardToken;\r\n    \r\n    // address mapped to how much they staked\r\n    mapping(address => uint256) public s_balances;\r\n\r\n    // a mapping of how much each address has been paid\r\n    mapping (address => uint256) public s_userRewardPerTokenPaid;\r\n\r\n    // a mapping of how much reward user has to claim\r\n    mapping (address => uint256) public s_rewards;\r\n\r\n    uint256 REWARD_RATE;\r\n    uint256 s_totalSupply;\r\n    uint256 s_rewardPerTokenStored;\r\n    uint256 s_latestUpdateTime;\r\n\r\n    modifier updateReward (address account){\r\n        // how much reward per token?\r\n        // last timestamp\r\n        // 12 - 1, user earned X tokens\r\n        s_rewardPerTokenStored = rewardPerToken();\r\n        s_latestUpdateTime = block.timestamp;\r\n        s_rewards[account] = earned(account);\r\n        s_userRewardPerTokenPaid[account] = s_rewardPerTokenStored;\r\n        _;\r\n    }\r\n\r\n    modifier moreThanZero(uint256 amount){\r\n        if(amount == 0){\r\n            revert Staking__NeedsMoreThanZero();\r\n        }\r\n        _;  // when you write a modifier code, this tells you to do whatever the function is doing after the modifier\r\n    }\r\n\r\n    constructor(address stakingToken, address rewardToken){\r\n        s_stakingToken = IERC20(stakingToken);\r\n        s_rewardToken = IERC20(rewardToken);\r\n    }    \r\n\r\n    function earned (address account ) public view returns(uint256){\r\n        uint256 currentBalance = s_balances[account];\r\n        // how much they have been paid already\r\n        uint256 ammountPaid = s_userRewardPerTokenPaid[account];\r\n        uint256 currentRewardPerToken = rewardPerToken();\r\n        uint256 pastRewards = s_rewards[account];\r\n        uint256 _earned = (currentBalance * (currentRewardPerToken - ammountPaid))/1e18 + pastRewards;\r\n        return _earned;\r\n    }\r\n\r\n    // how much reward per token\r\n    // based on how long it's been during this most recent snapshot\r\n    function rewardPerToken() public view returns(uint256) {\r\n        if (s_totalSupply == 0){\r\n            return s_rewardPerTokenStored;\r\n        }\r\n        return s_rewardPerTokenStored + (((block.timestamp - s_latestUpdateTime) * REWARD_RATE * 1e18)/ s_totalSupply);\r\n    }\r\n\r\n    // do we allow any tokens? - not allow any token\r\n    //      chainlink stuff to convert prices between tokens.\r\n    // or just a specific token?\r\n    function stake(uint256 amount) external updateReward(msg.sender) moreThanZero(amount){\r\n        // keep track of how much this user has staked\r\n        // keep track of how much token we have total\r\n        // transfer the tokens to this contract\r\n        s_balances[msg.sender] = s_balances[msg.sender] + amount;\r\n        s_totalSupply = s_totalSupply + amount;\r\n        // emit event\r\n        bool success = s_stakingToken.transferFrom(msg.sender, address(this), amount);\r\n        \r\n        // require(success, \"failed\");\r\n        if(!success) {\r\n            revert Staking__TransferFailed();\r\n        }\r\n    } \r\n    \r\n    function withdraw(uint256 amount) external updateReward(msg.sender){\r\n        s_balances[msg.sender] = s_balances[msg.sender] - amount;\r\n        s_totalSupply = s_totalSupply - amount;\r\n        bool success = s_stakingToken.transfer(msg.sender, amount);\r\n        //bool success = s_stakingToken.transferFrom(address(this), msg.sender, amount);\r\n        if (!success){\r\n            revert Staking__TransferFailed();\r\n        }\r\n    }\r\n\r\n    function claimReward() external updateReward(msg.sender) {\r\n        uint256 reward = s_rewards[msg.sender];\r\n        bool success = s_rewardToken.transfer(msg.sender, reward);\r\n        if (!success) {\r\n            revert Staking__TransferFailed();\r\n        }\r\n        // How much reward do they get?\r\n        \r\n        // The contract is going to emit X tokens per second\r\n        // And disperse them to all token stakers\r\n\r\n        // 100 tokens / second\r\n        // 50 staked tokens, 20 staked tokens, 30 staked tokens\r\n        // rewards: 50 reward tokens, 20 reward tokens, 30 reward tokens\r\n\r\n        // staked: 100, 50, 20, 30 (total = 200)\r\n        // reward: 50, 25, 10, 15\r\n\r\n        // why not 1 to 1? - bankrupt your protocol\r\n        \r\n\r\n        // 5 seconds, 1 person had 100 tokens staked = reward 500 tokens\r\n        // 6 seconds, 2 person have 100 tokens staked each:\r\n            // person 1: 550\r\n            // person 2: 50\r\n        \r\n        // ok between seconds 1 and 5, person 1 got 500 tokens\r\n        // ok at second 6 on, person 1 gets 50 tokens now\r\n    }\r\n\r\n    function getStaked(address account) public view returns(uint256) {\r\n        // get amount staked in the address\r\n        return s_balances[account];\r\n    }\r\n}\r\n\r\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}